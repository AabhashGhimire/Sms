<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hand Controlled Cube</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  video { display: none; }
  canvas {
    position: fixed;
    top: 0;
    left: 0;
  }
</style>
</head>

<body>

<video id="video" autoplay playsinline></video>
<canvas id="three"></canvas>

<!-- THREE -->
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

<!-- MEDIAPIPE -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ======================
   THREE SETUP
====================== */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("three"),
  antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);

/* ======================
   LIGHT
====================== */
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(3, 5, 5);
scene.add(light);

/* ======================
   CUBE
====================== */
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1.5, 1.5, 1.5),
  new THREE.MeshStandardMaterial({
    color: 0x00ffff,
    metalness: 0.6,
    roughness: 0.3
  })
);
scene.add(cube);

/* ======================
   HAND VARIABLES
====================== */
let pinchDistance = 0;
let targetScale = 1;

// rotation control
let rotateX = 0;
let rotateY = 0;

/* ======================
   HAND TRACKING
====================== */
const hands = new Hands({
  locateFile: f =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
});

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(res => {
  if (!res.multiHandLandmarks.length) return;

  const lm = res.multiHandLandmarks[0];

  /* ===== PINCH ZOOM ===== */
  const thumb = lm[4];
  const index = lm[8];

  pinchDistance = Math.hypot(
    thumb.x - index.x,
    thumb.y - index.y
  );

  // Map pinch distance to scale
  targetScale = THREE.MathUtils.clamp(
    pinchDistance * 6,
    0.5,
    3
  );

  /* ===== PALM DIRECTION ===== */
  const indexTip = lm[8];
  const pinkyTip = lm[20];
  const wrist = lm[0];

  const dx = indexTip.x - pinkyTip.x;
  const dy = indexTip.y - wrist.y;

  rotateX = 0;
  rotateY = 0;

  // LEFT / RIGHT
  if (dx > 0.15) rotateY = -0.05; // right
  if (dx < -0.15) rotateY = 0.05; // left

  // UP / DOWN
  if (dy < -0.15) rotateX = -0.05; // up
  if (dy > 0.15) rotateX = 0.05;  // down
});

/* ======================
   CAMERA FEED
====================== */
const video = document.getElementById("video");
const cam = new Camera(video, {
  onFrame: async () => {
    await hands.send({ image: video });
  },
  width: 640,
  height: 480
});
cam.start();

/* ======================
   ANIMATION LOOP
====================== */
function animate() {
  requestAnimationFrame(animate);

  // Smooth zoom
  cube.scale.lerp(
    new THREE.Vector3(targetScale, targetScale, targetScale),
    0.1
  );

  // Rotation from palm direction
  cube.rotation.x += rotateX;
  cube.rotation.y += rotateY;

  renderer.render(scene, camera);
}
animate();

/* ======================
   RESIZE
====================== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
